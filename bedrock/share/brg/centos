# Support functions for installing CentOS with brg (BedRock Get)

# Make sure all environment variables that are being used are set.

sanity_check()
{
    if [ -z "$mirror" ]; then
        mirror="http://mirror.centos.org/centos"
    fi

    if [ -z "$release" ]; then
        release=6
    fi

    if [ -z "$arch" ]; then
        echo "Architecture was not specified. This should not happen when run from brg, but " >&2
        echo "defaulting to $(uname -m). Sleeping for 5 seconds in case you want to cancel (ctrl-c)." >&2
        sleep 5
        arch=$(uname -m)
    fi

    case "$arch" in
        amd64|64|64-bit|x64)
            arch="x86_64";;
        32|32-bit|x86|i686)
            arch="i386";;
    esac

    if [ -z "$output" ]; then
        echo "Output directory was not specified. This definitely should not happen when running from brg." >&2
        echo "Terminating, please set the \"output\" environment variable if you need to use this manually." >&2
        exit 1
    fi

    #TODO: figure out/add tweaks
    if [ -n "${tweak}" ]; then
        echo "Warning: Bedrock tweaks not yet available for CentOS" >&2
    fi

    if [ -n "${section}" ]; then
        echo "Additional section not available, as no single extra repository is commonly enabled on CentOS." >&2
        echo "Please see http://wiki.centos.org/AdditionalResources/Repositories for suggestions." >&2
    fi

    release_url="${mirror}/${release}/os/${arch}"

    # rpm and its dependencies will be installed here, in order to install CentOS to the final destination
    brg_tmp="${output}/bootstrap"

    # These are absolute paths within the bootstrap environment
    workdir="/working" # packages are downloaded here
    stage2="/stage2" # the final target system is installed here

    sudo="" # Set this to "sudo" if you want to run most operations as a regular user (not functionality yet available through brg)
}


# There is no official listing of versions as far as I can tell, but the
# releases tend to be numbered so it is easy enough to discern from the file
# listing.

list_release()
{
    sanity_check
    mkdir -p -- "${brg_tmp}${workdir}"
    wget -q -O "${brg_tmp}${workdir}/filelist.gz" "${mirror}/filelist.gz"
    gunzip "${brg_tmp}${workdir}/filelist.gz"
    version_dirs=$(cut -d/ -f2 "${brg_tmp}${workdir}/filelist"| sort -ur | grep '^[0-9][0-9.]*$')
    for i in $version_dirs; do
        if grep -q "^./${i}/os" "${brg_tmp}${workdir}/filelist"; then
            echo "${i}"
        else
            echo "${i} *"
        fi
    done
    echo "Releases denoted with asterisks are likely only available in http://vault.centos.org/ and its mirrors."
    echo 'Bare numbers such as "5" and "6" tend to point to the latest point releases.'
}

# While they haven't recently, it is possible architectures will vary from
# release to release.  Listing all the release/architecture combinations in the
# filelist on the mirror.

list_arch()
{
    sanity_check
    arch_dirs=$(wget -q -O - ${mirror}/filelist.gz | zcat | cut -d/ -f2-4 | sort -ur | grep '^[0-9][0-9.]*/os/')
    for i in $arch_dirs; do
            echo "${i}" | sed 's|/os/| - |'
    done

    echo "Note that more releases and architectures may be available on http://vault.centos.org/ ."
}

# Download the XML data for the repository that will be needed for locating
# sqlite dependencies

prep_repodata()
{
    mkdir -p -- "${brg_tmp}${workdir}"
    wget -O "${brg_tmp}${workdir}/repomd.xml" "${release_url}/repodata/repomd.xml"
    
    # TODO: parse XML better, assuming less about formatting
    primary_xml=$(awk -F \" -f- "${brg_tmp}${workdir}/repomd.xml" <<'EOF'
        BEGIN {in_data=0;in_location=0} 
        /<data/ && /type="primary"/ { in_data=1 } 
        in_data && /<location/ {in_location=1} 
        in_location && /href="[^"]+"/ {print $2;exit} 
EOF
    ) # ") # fix vim syntax highlighting
    
    wget -O "${brg_tmp}${workdir}/primary.xml.gz" "${release_url}/${primary_xml}"
    printf -- "%s ${brg_tmp}${workdir}/primary.xml.gz" $(basename "${primary_xml}" | cut -d- -f1) | sha256sum -c
    gunzip "${brg_tmp}${workdir}/primary.xml.gz"
    sed -i 's/></>\n</g' "${brg_tmp}${workdir}/primary.xml"
    
    echo -n > "${brg_tmp}${workdir}/installed"
}

# Extract packages provided by repo RPM path on stdin if they are not already
# present in the file provided in the first argument. While installing, append
# entries to that file. This is used in initial bootstrapping, so it does not
# yet have rpm available, only rpm2cpio from busybox.

extract_packages()
{
    installed_file="${brg_tmp}${workdir}/installed"

    while read rpm_href; do 
        rpm=$(basename "${rpm_href}")
        if ! grep -qFx "${rpm}" "${installed_file}"; then
            echo "${rpm}" >> "${installed_file}"
            wget -c -O "${brg_tmp}${workdir}/${rpm}" "${release_url}/${rpm_href}"
            rpm2cpio "${brg_tmp}${workdir}/${rpm}" | (cd -- "${brg_tmp}"; $sudo cpio -id)
        fi
    done
}

# Fetch the dependencies for sqlite, the first step in bootstrapping, and print
# out the RPM URLS.  sqlite's dependent packages are hardcoded to keep them at
# a minimum and avoid too much XML parsing in shell.

fetch_sqlite_deps()
{
    case "$release" in
        5*)
            pkgs="
basesystem
bash
filesystem
glibc
glibc-common
info
libgcc
libsepol
libtermcap
mktemp
ncurses
readline
setup
sqlite
termcap
tzdata
zlib
" ;;
        *)
            pkgs="
basesystem
filesystem
glibc
glibc-common
libattr
libcap
libgcc
ncurses-base
ncurses-libs                                                                                                                                                   
nss-softokn-freebl
readline
setup
sqlite
tzdata
" ;;
    esac

    # TODO: parse XML better, assuming less about formatting
    for pkg in $pkgs; do
        rpm_href=$(awk -F \" -f- "${brg_tmp}${workdir}/primary.xml" <<EOF
            BEGIN {in_package=0;in_location=0}
            /<name>${pkg}<\/name>/ {in_package=1}
            in_package && /<arch>/ && ! /<arch>(${arch}|noarch)<\/arch>/ {in_package=0}
            in_package && /<location/ {in_location=1}
            in_location && /href="[^"]+"/ {print \$2;exit}
EOF
        ) # ") # fix vim syntax highlighting
        echo "${rpm_href}"
    done 
}

# Download and uncompress the repository in sqlite format for later dependency
# resolution.

prep_sqlite_data()
{
    # TODO: parse XML better, assuming less about formatting
    primary_db=$(awk -F \" -f- "${brg_tmp}${workdir}/repomd.xml" <<'EOF'
        BEGIN {in_data=0;in_location=0} 
        /<data/ && /type="primary_db"/ { in_data=1 } 
        in_data && /<location/ {in_location=1} 
        in_location && /href="[^"]+"/ {print $2;exit} 
EOF
    ) # ") #fix vim syntax highlighting

    # CentOS5 repo has an sqlite file, but it isn't mentioned in the metadata...
    if [ -z "${primary_db}" ]; then
        primary_db=$(dirname "${primary_xml}")/$(basename "${primary_xml}" .xml.gz).sqlite.bz2
    fi
    
    wget -O "${brg_tmp}${workdir}/primary.sqlite.bz2" "${release_url}/${primary_db}"
    printf -- "%s ${brg_tmp}${workdir}/primary.sqlite.bz2" $(basename "${primary_db}" | cut -d- -f1) | sha256sum -c
    bunzip2 "${brg_tmp}${workdir}/primary.sqlite.bz2"
}

# Returns an sqlite query to find dependencies for a package.
# Takes one argument containing the package to be installed.

get_deps_query()
{

# TODO: CentOS5-compatible sqlite...

setup="
-- CentOS repos list both 32-bit and 64-bit dependencies though both are not needed. Additionally,
-- the requires table's \"name\" column can refer both to specific files (found in the files table)
-- and dependency names (found in the provides table). This creates a simpler table to search only
-- including the necessary dependencies.
create temp table reqs_merged as 
    select requires.pkgKey as req,provides.pkgKey as dep from provides 
        join requires on requires.name = provides.name
        join packages on provides.pkgKey = packages.pkgKey
        where packages.arch = '${arch}' or packages.arch = 'noarch'
    union select requires.pkgKey,files.pkgKey from files 
        join requires on requires.name = files.name
        join packages on files.pkgKey = packages.pkgKey
        where packages.arch = '${arch}' or packages.arch = 'noarch';

create temp table result (pkgKey INTEGER PRIMARY KEY, name TEXT, location_href TEXT);

-- Recursion is used in the following trigger in order to go through the entire dependency tree.
PRAGMA recursive_triggers = on;

create temp trigger res_update after insert on result when
    -- Done once everything in the result table has dependencies already listed in the result table.
    (select count(*) from reqs_merged 
        where req in (select pkgKey from result)
        and dep not in (select pkgKey from result)) > 0 
    begin
        -- \"ignore\" is needed because the \"select pkgKey from result\" subquery
        -- runs before the recursive calls, causing duplicates
        insert or ignore into result 
        select distinct reqs_merged.dep,packages.name, packages.location_href from packages
        join reqs_merged on reqs_merged.dep = packages.pkgKey 
        join result on reqs_merged.req = result.pkgKey where reqs_merged.dep not in
            (select pkgKey from result);
     end;

"

package_clause="where name = '$1'"
shift
for package in "$@"; do
    package_clause="${package_clause} or name = '$package'"
done

query="
insert into result
    select pkgKey,name,location_href from packages ${package_clause};

select location_href from result;
"

echo "${setup} ${query}" 

}

# Run a query on primary.sqlite provided on stdin, returning the result on stdout
sql_query()
{
    $sudo chroot "${brg_tmp}" /usr/bin/sqlite3 "${workdir}/primary.sqlite"
}

# Fetch and install packages from rpm_hrefs provided on stdin to final destination,
# using bootstrapped rpm binary.
install_packages()
{
    fetch_log="${brg_tmp}${workdir}/fetch.log"
    echo -n > "${fetch_log}"
    mkdir -- "${brg_tmp}${stage2}"

    while read rpm_href; do 
        # CentOS 5 repo still has CentOS 5.9 sqlite repodata though the XML was updated...
        # primary.xml.gz        14-Oct-2013 18:52   1.3M
        # primary.sqlite.bz2    09-Oct-2013 19:47   2.3M
        # Hopefully this hack can be removed soon.
        if [ "$rpm_href" = "CentOS/centos-release-notes-5.9-0.x86_64.rpm" ]; then
            rpm_href="CentOS/centos-release-notes-5.10-0.x86_64.rpm"
        fi

        rpm=$(basename "${rpm_href}")
        if ! grep -qFx "${rpm}" "${fetch_log}"; then
            echo "${rpm}" >> "${fetch_log}"
            wget -c -O "${brg_tmp}${workdir}/${rpm}" "${release_url}/${rpm_href}"
        fi
    done

    # TODO: improve safety
    $sudo chroot "${brg_tmp}" sh -c "cd -- \"${workdir}\"; rpm --root "${stage2}" -ivh \$(cat fetch.log)"
}

# Move target out to final location and clean up bootstrap directory
finalize()
{
    mv -- "${brg_tmp}${stage2}/"* ${output}
    rm -r --  "${brg_tmp}"
}
update()
{
       $sudo chroot "${output}" yum update
}
install_with_yum()
{
    echo "$@"| tr ',' '\0' | xargs -n 50 -0 $sudo chroot "${output}" yum install
}


acquire()
{
    sanity_check
    prep_repodata
    fetch_sqlite_deps | extract_packages
    prep_sqlite_data
    get_deps_query rpm | sql_query | extract_packages
    get_deps_query yum centos-release | sql_query | install_packages
    finalize
    if [ -n "${update}" ]; then
        update
    fi
    if [ -n "${packages}" ]; then
        install_with_yum "${packages}"
    fi
}

